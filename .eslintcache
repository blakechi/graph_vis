[{"/Users/jibowei/Documents/React_learning/graph_vis/src/index.js":"1","/Users/jibowei/Documents/React_learning/graph_vis/src/App.js":"2","/Users/jibowei/Documents/React_learning/graph_vis/src/reportWebVitals.js":"3","/Users/jibowei/Documents/React_learning/graph_vis/src/Grid.js":"4","/Users/jibowei/Documents/React_learning/graph_vis/src/Scene.js":"5","/Users/jibowei/Documents/React_learning/graph_vis/src/nivoNetwork.js":"6","/Users/jibowei/Documents/React_learning/graph_vis/src/GridWrapper.js":"7","/Users/jibowei/Documents/React_learning/graph_vis/src/GraphSelector.jsx":"8","/Users/jibowei/Documents/React_learning/graph_vis/src/FlatGraphPlot.jsx":"9","/Users/jibowei/Documents/React_learning/graph_vis/src/vx_network/brewNetworkInput.js":"10","/Users/jibowei/Documents/React_learning/graph_vis/src/Scene_.js":"11","/Users/jibowei/Documents/React_learning/graph_vis/src/SceneLegend.jsx":"12","/Users/jibowei/Documents/React_learning/graph_vis/src/ButtonGroup.jsx":"13"},{"size":500,"mtime":1607601728593,"results":"14","hashOfConfig":"15"},{"size":848,"mtime":1607815217717,"results":"16","hashOfConfig":"15"},{"size":362,"mtime":1607043366380,"results":"17","hashOfConfig":"15"},{"size":2538,"mtime":1607824549324,"results":"18","hashOfConfig":"15"},{"size":29048,"mtime":1607822172058,"results":"19","hashOfConfig":"15"},{"size":998,"mtime":1607603276209,"results":"20","hashOfConfig":"15"},{"size":471,"mtime":1607603262546,"results":"21","hashOfConfig":"15"},{"size":733,"mtime":1607815757084,"results":"22","hashOfConfig":"15"},{"size":690,"mtime":1607822957426,"results":"23","hashOfConfig":"15"},{"size":751,"mtime":1607822943017,"results":"24","hashOfConfig":"15"},{"size":30789,"mtime":1607832412758,"results":"25","hashOfConfig":"15"},{"size":2240,"mtime":1607737286053,"results":"26","hashOfConfig":"15"},{"size":1908,"mtime":1607812438691,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"xnjig5",{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"37","messages":"38","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39","usedDeprecatedRules":"40"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"/Users/jibowei/Documents/React_learning/graph_vis/src/index.js",[],["57","58"],"/Users/jibowei/Documents/React_learning/graph_vis/src/App.js",[],"/Users/jibowei/Documents/React_learning/graph_vis/src/reportWebVitals.js",[],"/Users/jibowei/Documents/React_learning/graph_vis/src/Grid.js",[],"/Users/jibowei/Documents/React_learning/graph_vis/src/Scene.js",["59"],"import React, { Component } from \"react\";\n\nimport * as THREE from \"three\";\n// import TrackballControls from \"three-trackballcontrols\";\nimport ButtonGroup from \"./ButtonGroup\";\nimport SceneLegend from \"./SceneLegend\";\n\nclass Scene extends Component {\n    componentDidMount() {\n        var color_pick = [\"rgb(0,0,254)\", \"rgb(0,204,0)\", \"rgb(102,0,204)\"];\n        \n        //transition visible var\n        var threshold = 0.0;\n\n        //name var\n        var str1 = \"node\";\n        var str2 = \"edge\";\n        var str3 = \"group\";\n        var str4 = \"tran\";\n        var str5 = \"spritey\";\n\n        const SCREEN_WIDTH = window.innerWidth - 20; // Seems that this.mount.clientWidth won't update immediately\n        const SCREEN_HEIGHT = this.mount.clientHeight; // Grid Height\n\n        this.this.scene = new THREE.this.scene();\n\n        //Add Renderer\n        this.renderer = new THREE.WebGLRenderer({ antialias: true, aplpha: false });\n        this.renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);\n        this.renderer.setClearColor(0x000000, 1);\n        this.renderer.gammaInput = true;\n        this.renderer.gammaOutput = true;\n        this.mount.appendChild(this.renderer.domElement);\n\n        //this.camera var\n        var VIEW_ANGLE = 45,\n            ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT,\n            NEAR = 0.1,\n            FAR = 20000;\n        this.lookat_point;\n\n        //basic var\n        this.camera = new THREE.Perspectivethis.camera( VIEW_ANGLE, ASPECT, NEAR, FAR);\n        this.this.scene.add(this.camera);\n        this.camera.position.set(0,150,1200);\n        this.camera.lookAt(this.this.scene.position);\n        this.lookat_point = this.this.scene.position;\n        this.camera_position = this.camera.position.clone();\n        this.camera_rotation = this.camera.rotation.clone();\t\n\n        //group var\n        this.trans_group = new THREE.Group();\n        var graph_group = new THREE.Group();\n\n        //ray casting var\n        var INTERSECTED;\n        var spritey;\n        this.spritey_name_list =[];\n        var targetList = [];\n        var todoList =[];\n        var raycaster = new THREE.Raycaster(); // create once\n        var mouse = new THREE.Vector2(); // create once\n        var trans = new THREE.Vector3(0,0,80);\n\n        //for this.scene2 var\n        var container,\n        container2,\n        renderer2,\n        this.scene2,\n        axes2,\n        this.camera2,\n        CANVAS_WIDTH = SCREEN_WIDTH*0.25,\n        CANVAS_HEIGHT = SCREEN_HEIGHT*0.25,\n        CAM_DISTANCE = 1000;\n\n        //data var: sphere_data, edge_data, group_data, transition_data\n        var sphere_data=[],\n        edge_data=[],\n        transition_data = [];\n\n        var group_data = [\n                new THREE.Vector3(-600,0,0),\n                new THREE.Vector3(-200,0,0),\n                new THREE.Vector3(200,0,0),\n                new THREE.Vector3(600,0,0),\n        ];\n\n        for(let i=0;i<data[str_data].node_positions.length;i++) {\n            sphere_data.push([\n                new THREE.Vector3((data[str_data].node_positions[i][0]-0.5)*400,\n                                (data[str_data].node_positions[i][1]-0.5)*400,\n                                (data[str_data].node_positions[i][2]-0.5)*400)\n                                ,color_pick[data[str_data].node_label[i]]]);\n        }\n        edge_data = data[str_data].adjacency_matrix;\n        transition_data = data[str_data].attention_weights;\n\n\n        this.controls = new TrackballControls( this.camera, this.renderer.domElement );\n        this.controls.minDistance = 100.1;\n        this.controls.maxDistance = 10000.5;\n\n        //Simple Box with WireFrame\n        this.addModels();\n\n        // this.renderthis.scene();\n        // //start animation\n        // this.start();\n\n        this.animate();\n\n        window.addEventListener(\"resize\", this.handleWindowResize);\n    }\n\n    componentDidUpdate() {\n        this.mount.setAttribute(\"clientWidth\", window.innerWidth - 20);\n    }\n\n    componentWillUnmount() {\n        this.stop();\n        this.mount.removeChild(this.renderer.domElement);\n\n        window.removeEventListener(\"resize\", this.handleWindowResize);\n    }\n\n    handleWindowResize = () => {\n        // from https://stackoverflow.com/questions/29884485/threejs-canvas-size-based-on-container\n        const width = window.innerWidth - 20;\n        const height = this.mount.clientHeight;\n        // console.log(window.innerWidth, this.props.width, this.mount.clientWidth);\n\n        this.camera.aspect = width / height;\n        this.camera.updateProjectionMatrix();\n        this.renderer.setSize(width, height);\n        this.renderer.render(this.this.scene, this.camera);\n        this.controls.handleResize();\n    };\n\n    init = () => {\n        // make_graph();\n        make_this.scene();\n        document.addEventListener( 'mousemove', onDocumentMouseMove, false );\n        document.addEventListener( 'keydown', Keyboard, false );\n        // var sphere_position = new THREE.Vector3(100, 50, -50);\n        // var sphere = make_sphere(0x8888ff,\"sphere1\",sphere_position);\n        // this.scene.add(sphere);\n        // var group = make_group((0,0,0));\n        // this.scene.add(group);\n    }\n    \n    animate = () => {\n        requestAnimationFrame( animate );\n        controls.update();\n        hover_color_update();\n        this.camera2.position.copy( this.camera.position );\n        this.camera2.position.sub( controls.target ); // added by @libe\n        this.camera2.position.setLength( CAM_DISTANCE );\n        this.camera2.lookAt( this.scene2.position );\n        renderer.render( this.scene, this.camera );\n        renderer2.render( this.scene2, this.camera2 );\n    }\n    \n    \n    make_sphere = (sphere_name , sphere_position , sphere_color ) => {\n        var sphereGeometry = new THREE.SphereGeometry( 12, 32, 16 );\n        var sphereMaterial = new THREE.MeshBasicMaterial( {color: sphere_color} ); \n        sphereMaterial.transparent = true;\n        var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);\n        sphere.name = sphere_name;\n        sphere.position.copy(sphere_position);\n        sphere.castShadow = true;\n        // console.log(sphere);\n        targetList.push(sphere);\n        return sphere;\n    }\n    \n    make_edge = (cylinder_name, group , sphere1_name , sphere2_name, value) => {\n    \n        var position1 = group.getObjectByName(sphere1_name).position.clone();\n        var position2 = group.getObjectByName(sphere2_name).position.clone();\n        var distance = position1.distanceTo(position2);\n        var cylinderGeometry = new THREE.CylinderGeometry(2,2,distance,32);\n        var cylinderMaterial = new THREE.MeshBasicMaterial({\n            color: 'rgb(125,125,125)'\n        });\n        cylinderMaterial.transparent = true;\n        cylinderGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, distance / 2, 0 ) );\n        // rotate it the right way for lookAt to work\n        cylinderGeometry.applyMatrix( new THREE.Matrix4().makeRotationX( THREE.Math.degToRad( 90 ) ) );\n        // Make a mesh with the geometry\n        var cylinder = new THREE.Mesh( cylinderGeometry, cylinderMaterial );\n        // Position it where we want\n        cylinder.position.copy( position1 );\n        // And make it point to where we want\n        cylinder.lookAt( position2 );\n    \n        // cylinder.position.copy(center);\n        cylinder.castShadow = true;\n        cylinder.name = cylinder_name;\n        // console.log(cylinder);\n        // targetList.push(cylinder);\n    \n        return cylinder;\n    }\n    \n    make_group = (group_name , group_position) => {\n        var group = new THREE.Group();\n    \n        var sphere = [];\n        var edge = [];\n    \n        for(let i=0;i<sphere_data.length;i++)\n        {\n            sphere.push([i.toString().concat(str1) , sphere_data[i][0] , sphere_data[i][1]]);\n            for(let j=i;j<sphere_data.length;j++)\n            {\n                edge.push([(i*sphere_data.length+j).toString().concat(str2),\n                            i.toString().concat(str1),\n                            j.toString().concat(str1),\n                            edge_data[i][j]]);\n            }\n        }\n    \n    \n        sphere.map(ele => group.add(\n            make_sphere(ele[0], ele[1], ele[2])\n        ));\n        \n        edge.map(ele => \n        {\n            if (ele[3]===1) {\n                group.add(make_edge(ele[0], group , ele[1] , ele[2] , ele[3]));\n            }\n        }\n        );\n    \n    \n        group.position.copy(group_position);\n        group.name = group_name;\n        // console.log(group);\n        // console.log(group.children[0]);\n        return group;\n    }\n    \n    \n    make_graph = () => {\n        var group = [];\n        graph_group.name = \"graph_group\";\n        for(let i=0;i<group_data.length;i++)\n        {\n            group.push([i.toString().concat(str3),group_data[i]]);\n        }\n    \n        group.map(ele => graph_group.add(\n            make_group(ele[0],ele[1])\n        ));\n        // console.log(graph_group);\n        this.scene.add(graph_group);\n    }\n    \n    make_transition = (transition_name, group1_name , group2_name , sphere1_name , sphere2_name , value) =>{\n    \n        if(value>1.0)\n            value = 1.0;\n        //color\n        var ar = 255,\n            ag = 128,\n            ab = 0,\n            br = 255,\n            bg = 0,\n            bb = 0;\n    \n        var r = Math.floor((br-ar)*(value-threshold)/(1-threshold) + ar);\n        var g = Math.floor((bg-ag)*(value-threshold)/(1-threshold) + ag);\n        var b = Math.floor((bb-ab)*(value-threshold)/(1-threshold) + ab);\n    \n        var color1 = 'rgb(';\n        var append1 = ',';\n        var append2 = ')';\n        var color = color1.concat(r.toString(),append1,g.toString(),append1,b.toString(),append2);\n        var position1 = this.scene.getObjectByName(group1_name).getObjectByName(sphere1_name).position.clone();\n        var position2 = this.scene.getObjectByName(group2_name).getObjectByName(sphere2_name).position.clone();\n        position1.add(this.scene.getObjectByName(group1_name).position);\n        position2.add(this.scene.getObjectByName(group2_name).position);\n        var center =  position1.clone();\n        center.add(position2.clone());\n        center.divideScalar(2.0);\n        center.add(trans);\n        // console.log(position1,position2);\n        // console.log(center);\n        var distance = position1.distanceTo(position2);\n        var cylinderGeometry = new THREE.CylinderGeometry(2,2,distance,32);\n        var cylinderMaterial = new THREE.MeshBasicMaterial({\n            color: color\n        });\n        cylinderMaterial.shininess = 50;\n        cylinderMaterial.transparent = true;\n        cylinderMaterial.opacity = 0.5;\n    \n        cylinderGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, distance / 2, 0 ) );\n        // rotate it the right way for lookAt to work\n        cylinderGeometry.applyMatrix( new THREE.Matrix4().makeRotationX( THREE.Math.degToRad( 90 ) ) );\n        // Make a mesh with the geometry\n        var cylinder = new THREE.Mesh( cylinderGeometry, cylinderMaterial );\n        // Position it where we want\n        cylinder.position.copy( position1 );\n        // And make it point to where we want\n        cylinder.lookAt( position2 );\n    \n        // cylinder.position.copy(center);\n        cylinder.castShadow = true;\n        cylinder.name = transition_name;\n        cylinder.userData = {value: value, position: center};\n        cylinder.visible = false;\n        // console.log(cylinder);\n        // targetList.push(cylinder);\n    \n        return cylinder;\n    }\n    \n    make_scene = () => {\n        this.make_graph();\n        var transition = [];\n        this.trans_group.name = \"this.trans_group\";\n        for(let i=0;i<(group_data.length-1);i++)\n        {\n            for(let j=0;j<sphere_data.length;j++)\n            {\n                for(let k=0;k<sphere_data.length;k++)\n                {\n                    transition.push([\n                        ((i*sphere_data.length*sphere_data.length)+j*sphere_data.length+k).toString().concat(str4), \n                        i.toString().concat(str3),\n                        (i+1).toString().concat(str3),\n                        j.toString().concat(str1),\n                        k.toString().concat(str1),\n                        transition_data[i][j][k]\n                    ]);\n                }\n            }\n        }\n    \n        // var transition = [\n        // \t['transition1','group1','group2','sphere1','sphere2','rgb(255,0,0)']\n        // ];\n    \n        transition.map(ele => {\n            if (ele[5]>threshold){\n                this.trans_group.add(make_transition(ele[0],ele[1],ele[2],ele[3],ele[4],ele[5]));\n            }\n        }\n        );\n        // console.log(this.trans_group);\n        this.this.scene.add(this.trans_group);\n    }\n    \n    \n    \n    //mouse action\n    onDocumentMouseMove = ( event ) => {\n        // the following line would stop any other event handler from firing\n        // (such as the mouse's TrackballControls)\n        // event.preventDefault();\n        \n        // update the mouse variable\n        mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;\n        mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;\n    \n    }\n    \n    hover_color_update = () => {\n        // find intersections\n    \n        // create a Ray with origin at the mouse position\n        //   and direction into the this.scene (this.camera direction)\n        // raycaster = new THREE.Raycaster();\n    \n        // create an array containing all objects in the this.scene with which the ray intersects\n        raycaster.setFromthis.camera( mouse, this.camera );\n        var intersects = raycaster.intersectObjects( targetList );\n    \n        // INTERSECTED = the object in the this.scene currently closest to the this.camera \n        //\t\tand intersected by the Ray projected from the mouse position \t\n        \n        // if there is one (or more) intersections\n        var group_num,sphere_num;\n        if ( intersects.length > 0 )\n        {\n            // if the closest object intersected is not the currently stored intersection object\n            if ( intersects[ 0 ].object !== INTERSECTED ) \n            {\n                // restore previous intersection object (if it exists) to its original color\n                if ( INTERSECTED ) \n                {\n                    // if(INTERSECTED.geometry.type===\"SphereGeometry\")\n                    // {\t\n                        //reset\n                    INTERSECTED.material.color.setHex( INTERSECTED.currentHex );\n                    for(let i=0;i<group_data.length;i++)\n                    {\n                        for(let j=0;j<graph_group.children[i].children.length;j++)\n                        {\n                            graph_group.children[i].children[j].material.opacity = 1.0;\n                        }\n                    }\n                    for(let i=0;i<this.trans_group.children.length;i++)\n                    {\n                        this.trans_group.children[i].visible = false;\n                    }\n                    while(this.spritey_name_list.length!==0)\n                    {\n                        this.scene.remove(this.scene.getObjectByName(this.spritey_name_list[(this.spritey_name_list.length-1)]));\n                        this.spritey_name_list.pop();\n                    }\n                    spritey = null;\n                }\n                // store reference to closest object as current intersection object\n                INTERSECTED = intersects[ 0 ].object;\n                \n                    //set everything to low opacity state\n                for(let i=0;i<group_data.length;i++)\n                {\n                    for(let j=0;j<graph_group.children[i].children.length;j++)\n                    {\n                        graph_group.children[i].children[j].material.opacity = 0.33;\n                    }\n                }\n    \n                //get object that want to be stand out (transition and origin)\n                todoList.push(INTERSECTED);\n                // console.log(INTERSECTED);\n                while (todoList.length!==0)\n                {\n                    var todoObject = todoList[(todoList.length-1)];\n                    todoList.pop();\n    \n                    spritey = makeTextSprite( parseInt(todoObject.name).toString(), \n                    { fontsize: 75, fontface: \"Georgia\", borderColor: {r:0, g:0, b:255, a:1.0} } );\n                    var temp_position = (todoObject.position.clone());\n                    temp_position.add(todoObject.parent.position);\n                    spritey.position.copy(temp_position);\n                    spritey.position.add(trans);\n                    spritey.name = todoObject.name.concat(str5);\n                    this.spritey_name_list.push(spritey.name);\n                    // console.log(spritey);\n                    this.scene.add( spritey );\n    \n                    todoObject.material.opacity = 1.0;\n                    sphere_num = parseInt(todoObject.name);\n                    group_num = parseInt(todoObject.parent.name);\n                    // console.log(sphere_num,group_num);\n                    if(group_num!==0)\n                    {\n                        for(let i=0;i<this.trans_group.children.length;i++)\n                        {\n                            var test_num = (parseInt(this.trans_group.children[i].name)\n                                -((group_num-1)*sphere_data.length*sphere_data.length));\n                            if(\n                                ((test_num%sphere_data.length) === sphere_num)\n                                &&(test_num<(sphere_data.length*sphere_data.length))\n                                &&(test_num>0)\n                                )\n                            {\n                                // console.log(test_num);\n                                // this.trans_group.children[i].material.opacity = 1.0;\n                                this.trans_group.children[i].visible = true;\n                                var num = Math.floor(test_num/sphere_data.length);\n                                // console.log(graph_group.children[(group_num-1)].children[num]);\n                                todoList.push(graph_group.children[(group_num-1)].children[num]);\n                            }\n                        }\n                    }\n                }\n    \n                //set object connection in its own graph\n                sphere_num = parseInt(INTERSECTED.name);\n                group_num = parseInt(INTERSECTED.parent.name);\n                var temp_num;\n                for(let i =0;i<group_data.length;i++)\n                {\n                    if(i===group_num)\n                    {\n                        for(let j = 0;j<sphere_data.length;j++)\n                        {\n                            if(j!==sphere_num)\n                            {\n                                INTERSECTED.parent.children[j].material.opacity = 0.33;\n                            }\n                        }\n                        for(let j=sphere_data.length;j<INTERSECTED.parent.children.length;j++)\n                        {\n                            if((parseInt(INTERSECTED.parent.children[j].name)%sphere_data.length) === sphere_num)\n                            {\n                                temp_num = Math.floor(parseInt(INTERSECTED.parent.children[j].name)/sphere_data.length);\n                                INTERSECTED.parent.children[temp_num].material.opacity = 1.0;\n                                INTERSECTED.parent.children[j].material.opacity = 1.0;\n                            }\n                            else if ((Math.floor(parseInt(INTERSECTED.parent.children[j].name)/sphere_data.length))=== sphere_num) \n                            {\n                                temp_num = parseInt(INTERSECTED.parent.children[j].name)%sphere_data.length;\n                                INTERSECTED.parent.children[temp_num].material.opacity = 1.0;\n                                INTERSECTED.parent.children[j].material.opacity = 1.0;\n                            }\n                        }\n                    }\n                }\n    \n                //set itself to a highlight color\n                // store color of closest object (for later restoration)\n                INTERSECTED.currentHex = INTERSECTED.material.color.getHex();\n                // set a new color for closest object\n                INTERSECTED.material.color.setHex( 0xFC4AD9 );\n            }\n        } \n        else // there are no intersections\n        {\n            // restore previous intersection object (if it exists) to its original color\n            if ( INTERSECTED ) \n            {\n                // if(INTERSECTED.geometry.type===\"SphereGeometry\")\n                // {\n                    //reset\n                INTERSECTED.material.color.setHex( INTERSECTED.currentHex );\n                for(let i=0;i<group_data.length;i++)\n                {\n                    for(let j=0;j<graph_group.children[i].children.length;j++)\n                    {\n                        graph_group.children[i].children[j].material.opacity = 1.0;\n                    }\n                }\n                for(let i=0;i<this.trans_group.children.length;i++)\n                {\n                    this.trans_group.children[i].visible = false;\n                }\n                while(this.spritey_name_list.length!==0)\n                {\n                    this.scene.remove(this.scene.getObjectByName(this.spritey_name_list[(this.spritey_name_list.length-1)]));\n                    this.spritey_name_list.pop();\n                }\n                spritey = null;\n            }\n            // remove previous intersection object reference\n            //     by setting current intersection object to \"nothing\"\n            INTERSECTED = null;\n        }\n    \n    }\n    \n    Keyboard = (event) => {\n        if(event.keyCode===72){\n            this.camera.position.set(this.camera_position);\n            this.camera.rotation.set(this.camera_rotation);\n            this.lookat_point.x = 0;\n            this.lookat_point.y = 0;\n            this.lookat_point.z = 0;\n            this.camera.lookAt(this.lookat_point);\n            controls.reset();\t\n        }\n        //A x-left\n        if(event.keyCode===65){\n            this.camera.position.x = this.camera.position.x-100;\n            this.lookat_point.x = this.lookat_point.x + 100;\n            this.camera.lookAt(this.lookat_point);\n        }\n        //D x-right\n        if(event.keyCode===68){\n            this.camera.position.x = this.camera.position.x+100;\n            this.lookat_point.x = this.lookat_point.x - 100;\n            this.camera.lookAt(this.lookat_point);\n        }\n        //W y-up\n        if(event.keyCode===87){\n            this.camera.position.y = this.camera.position.y+100;\n            this.lookat_point.y = this.lookat_point.y - 100;\n            this.camera.lookAt(this.lookat_point);\n        }\n        //S y-down\n        if(event.keyCode===83){\n            this.camera.position.y = this.camera.position.y-100;\n            this.lookat_point.y = this.lookat_point.y + 100;\n            this.camera.lookAt(this.lookat_point);\n        }\n        //N -come near\n        if(event.keyCode===78){\n            this.camera.position.z = this.camera.position.z+100;\n            this.lookat_point.z = this.lookat_point.z - 100;\n            this.camera.lookAt(this.lookat_point);\n        }\n        //M -go far\n        if(event.keyCode===77){\n            this.camera.position.z = this.camera.position.z-100;\n            this.lookat_point.z = this.lookat_point.z + 100;\n            this.camera.lookAt(this.lookat_point);\n        }\n    }\n    \n    makeTextSprite = ( message, parameters ) => {\n        if ( parameters === undefined ) parameters = {};\n        var fontface = parameters.hasOwnProperty(\"fontface\") ? parameters[\"fontface\"] : \"Arial\";\n        var fontsize = parameters.hasOwnProperty(\"fontsize\") ? parameters[\"fontsize\"] : 18;\n        var borderThickness = parameters.hasOwnProperty(\"borderThickness\") ? parameters[\"borderThickness\"] : 4;\n        var borderColor = parameters.hasOwnProperty(\"borderColor\") ?parameters[\"borderColor\"] : { r:0, g:0, b:0, a:1.0 };\n        var backgroundColor = parameters.hasOwnProperty(\"backgroundColor\") ?parameters[\"backgroundColor\"] : { r:255, g:255, b:255, a:1.0 };\n        var textColor = parameters.hasOwnProperty(\"textColor\") ?parameters[\"textColor\"] : { r:0, g:0, b:0, a:1.0 };\n    \n        var canvas = document.createElement('canvas');\n        var context = canvas.getContext('2d');\n        context.font = \"Bold \" + fontsize + \"px \" + fontface;\n        var metrics = context.measureText( message );\n        var textWidth = metrics.width;\n    \n        context.fillStyle   = \"rgba(\" + backgroundColor.r + \",\" + backgroundColor.g + \",\" + backgroundColor.b + \",\" + backgroundColor.a + \")\";\n        context.strokeStyle = \"rgba(\" + borderColor.r + \",\" + borderColor.g + \",\" + borderColor.b + \",\" + borderColor.a + \")\";\n    \n        context.lineWidth = borderThickness;\n        roundRect(context, borderThickness/2, borderThickness/2, (textWidth + borderThickness) * 1.1, fontsize * 1.4 + borderThickness, 8);\n    \n        context.fillStyle = \"rgba(\"+textColor.r+\", \"+textColor.g+\", \"+textColor.b+\", 1.0)\";\n        context.fillText( message, borderThickness, fontsize + borderThickness);\n    \n        var texture = new THREE.Texture(canvas) \n        texture.needsUpdate = true;\n    \n        var spriteMaterial = new THREE.SpriteMaterial( { map: texture, useScreenCoordinates: false } );\n        var sprite = new THREE.Sprite( spriteMaterial );\n        sprite.scale.set(0.5 * fontsize, 0.25 * fontsize, 0.75 * fontsize);\n        return sprite;  \n    }\n    \n    roundRect = (ctx, x, y, w, h, r) => { \n        ctx.beginPath(); ctx.moveTo(x + r, y); \n        ctx.lineTo(x + w - r, y); \n        ctx.quadraticCurveTo(x + w, y, x + w, y + r); \n        ctx.lineTo(x + w, y + h - r); \n        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h); \n        ctx.lineTo(x + r, y + h); \n        ctx.quadraticCurveTo(x, y + h, x, y + h - r); \n        ctx.lineTo(x, y + r); \n        ctx.quadraticCurveTo(x, y, x + r, y); \n        ctx.closePath(); ctx.fill(); ctx.stroke(); \n    }\n\n    start = () => {\n        if (!this.frameId) {\n            this.frameId = requestAnimationFrame(this.animate);\n        }\n    };\n\n    stop = () => {\n        cancelAnimationFrame(this.frameId);\n    };\n\n    animate = () => {\n        this.frameId = window.requestAnimationFrame(this.animate);\n        if (this.toggle !== this.props.toggle) {\n            this.cube.forEach((ele) => {\n                this.this.scene.remove(ele);\n            });\n            this.addModels();\n            this.toggle = this.props.toggle;\n        }\n\n        if (this.cube) {\n            this.cube.forEach((ele) => {\n                ele.rotation.y += 0.01;\n            });\n        }\n\n        this.renderthis.scene();\n    };\n\n    render_scene = () => {\n        if (this.renderer) this.renderer.render(this.this.scene, this.camera);\n    };\n\n    render() {\n        return (\n            <div\n                style={{ width: this.props.width, height: this.props.height }}\n                ref={(ref) => {\n                    this.mount = ref;\n                }}\n            >\n                <SceneLegend />\n                <ButtonGroup width={this.props.width} />\n            </div>\n        );\n    }\n}\n\nexport default this.scene;\n",["60","61"],"/Users/jibowei/Documents/React_learning/graph_vis/src/nivoNetwork.js",[],"/Users/jibowei/Documents/React_learning/graph_vis/src/GridWrapper.js",[],"/Users/jibowei/Documents/React_learning/graph_vis/src/GraphSelector.jsx",[],"/Users/jibowei/Documents/React_learning/graph_vis/src/FlatGraphPlot.jsx",[],"/Users/jibowei/Documents/React_learning/graph_vis/src/vx_network/brewNetworkInput.js",[],"/Users/jibowei/Documents/React_learning/graph_vis/src/Scene_.js",[],"/Users/jibowei/Documents/React_learning/graph_vis/src/SceneLegend.jsx",[],"/Users/jibowei/Documents/React_learning/graph_vis/src/ButtonGroup.jsx",[],{"ruleId":"62","replacedBy":"63"},{"ruleId":"64","replacedBy":"65"},{"ruleId":null,"fatal":true,"severity":2,"message":"66","line":69,"column":9},{"ruleId":"62","replacedBy":"67"},{"ruleId":"64","replacedBy":"68"},"no-native-reassign",["69"],"no-negated-in-lhs",["70"],"Parsing error: Unexpected keyword 'this'\n\n\u001b[0m \u001b[90m 67 | \u001b[39m        container2\u001b[33m,\u001b[39m\u001b[0m\n\u001b[0m \u001b[90m 68 | \u001b[39m        renderer2\u001b[33m,\u001b[39m\u001b[0m\n\u001b[0m\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 69 | \u001b[39m        \u001b[36mthis\u001b[39m\u001b[33m.\u001b[39mscene2\u001b[33m,\u001b[39m\u001b[0m\n\u001b[0m \u001b[90m    | \u001b[39m        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\u001b[0m\n\u001b[0m \u001b[90m 70 | \u001b[39m        axes2\u001b[33m,\u001b[39m\u001b[0m\n\u001b[0m \u001b[90m 71 | \u001b[39m        \u001b[36mthis\u001b[39m\u001b[33m.\u001b[39mcamera2\u001b[33m,\u001b[39m\u001b[0m\n\u001b[0m \u001b[90m 72 | \u001b[39m        \u001b[33mCANVAS_WIDTH\u001b[39m \u001b[33m=\u001b[39m \u001b[33mSCREEN_WIDTH\u001b[39m\u001b[33m*\u001b[39m\u001b[35m0.25\u001b[39m\u001b[33m,\u001b[39m\u001b[0m",["69"],["70"],"no-global-assign","no-unsafe-negation"]